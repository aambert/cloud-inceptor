#!/bin/bash

SCRIPT_HOME=$(cd $(dirname "$(ls -l $0 | awk '{ print $NF }')") && pwd)
source $SCRIPT_HOME/common

set -ex

#
# Setup hostname to map to domain
#
if [[ -n $config_server_fqdn ]]; then
    echo "$config_server_fqdn" > /etc/hostname
    hostname $config_server_fqdn

    sed -i \
        "s|^127.0.1.1.*$|127.0.1.1\t${config_server_fqdn}  ${config_server_fqdn%%.*}|" \
        /etc/hosts

    sed -i \
        "s|^$config_server_private_ip.*$|$config_server_private_ip  ${config_server_fqdn}  ${config_server_fqdn%%.*}|" \
        /etc/hosts
fi

#
# Configure Users and SSH Access
#

if [[ -e /data/users/etc ]]; then
    cp -r /data/users/etc/* /etc
else
    mkdir -p /data/users/home
    mkdir -p /data/users/etc
    mkdir -p /data/users/etc/ssh
fi

if [[ -n "$config_server_admin_passwd" ]]; then

    admin_user=${config_server_admin_user:-admin}
    admin_password=$(mkpasswd "$config_server_admin_passwd")
    user_home=/data/users/home/$admin_user

    set +e
    id $admin_user >/dev/null 2>&1
    if [[ $? -ne 0 ]]; then
        useradd $admin_user -p $admin_password -m -d $user_home -s /bin/bash
    else
        usermod $admin_user -p $admin_password -m -d $user_home -s /bin/bash
    fi
    adduser $admin_user sudo

    mkdir -p $user_home/.ssh
    echo "$config_server_admin_ssh_public_key" \
        > $user_home/.ssh/authorized_keys

    chmod -R 0644 $user_home/.ssh

    # Remove any overrides that may 
    # allow passwordless sudos
    rm -fr /etc/sudoers.d/*
    sed -i 's|%sudo ALL=(ALL:ALL) NOPASSWD:ALL|%sudo ALL=(ALL:ALL) ALL|' /etc/sudoers
    
    set -e
    [[ -n "$config_server_admin_ssh_port" ]] && \
        sed -i "s|^Port [0-9]*$|Port $config_server_admin_ssh_port|" /etc/ssh/sshd_config

    service sshd restart
fi

# Fix to remove "mesg: ttyname failed: Inappropriate ioctl for device" 
# from output when executing commands with 'sudo -i'
sed -i 's/^mesg n || true$/tty -s \&\& mesg n/' /root/.profile

#
# Configure NICS
#

set +x
echo -e "\n============================= Network Interfaces =============================="
ip a
echo -e "=================================== Routes ===================================="
route -n
echo -e "===============================================================================\n"
set -x

public_itf=$(ip a \
    | grep -B 5 "$config_server_private_ip" \
    | awk '/^[0-9]+: (eth|ens?)[0-9]+:/{ print substr($2,1,length($2)-1) }')

if [[ -z $public_itf ]]; then
    # Remove cloud-config network setup
    rm -f /etc/network/interfaces.d/50-cloud-init.cfg
fi

itfs=( $(ip a | grep "^[0-9]*: " | awk '{ print substr($2,1,length($2)-1) }') )
i=0
j=51

for n in $(echo $config_server_lan_interfaces | sed "s/,/ /g"); do

    i=$(($i+1))
    itf=${itfs[$i]}
    
    ip=$(echo $n | awk -F'|' '{print $1}')    
    netmask=$(echo $n | awk -F'|' '{print $2}')
    lan_subnet=$(echo $n | awk -F'|' '{print $3}')
    lan_netmask=$(echo $n | awk -F'|' '{print $4}')
    lan_gateway=$(echo $n | awk -F'|' '{print $5}')

    if [[ $itf != $public_itf ]]; then

        set +e

        ifdown $itf
        ip address flush dev $itf

        if [[ -n $ip ]]; then        
            # Configure a static IP

            if [[ -n $lan_subnet && -n $lan_gateway ]]; then
                # Configure a static route

                cat << ---EOF > /etc/network/interfaces.d/$j-$itf.cfg
auto $itf
iface $itf inet static
    address $ip
    netmask $lan_netmask
    post-up /sbin/route add -net $lan_subnet gw $lan_gateway
    post-down /sbin/route del -net $lan_subnet
---EOF
            else
            
                cat << ---EOF > /etc/network/interfaces.d/$j-$itf.cfg
auto $itf
iface $itf inet static
    address $ip
    netmask $netmask
---EOF

            fi
        else
            # Configure DHCP

            cat << ---EOF > /etc/network/interfaces.d/$j-$itf.cfg
auto $itf
iface $itf inet dhcp
---EOF
        fi

        ifup $itf
        set -e
        
        j=$(($j+1))
    fi
done

#
# Configure Docker daemon
#

systemctl enable docker
set +e

if [[ -n $config_server_docker_mount_path ]]; then

    i=0
    mount | grep " $config_server_docker_mount_path " >/dev/null 2>&1
    while [[ $i -lt 12 && $? -ne 0 ]]; do
        echo "Waiting for docker root mount '$config_server_docker_mount_path' to become available..."
        sleep 5
        i=$(($i+1))
        mount | grep " $config_server_docker_mount_path " >/dev/null 2>&1
    done
    if [[ $i -lt 12 ]]; then
        echo "Changing docker root path to '$config_server_docker_mount_path'."

        systemctl stop docker

        mkdir -p /etc/systemd/system/docker.service.d
        cat << ---EOF > /etc/systemd/system/docker.service.d/docker.root.conf
[Service]
ExecStart=
ExecStart=/usr/bin/dockerd --data-root $config_server_docker_mount_path/docker
---EOF

        systemctl daemon-reload
    else
        echo "Timed out waiting for docker root mount path to become available. No changes will be made to docker root path."
    fi
fi

set -e
systemctl restart docker

set +ex
touch /root/.network_installed
