#!/bin/bash

set -exo pipefail

SCRIPT_HOME=$(cd $(dirname "$(ls -l $0 | awk '{ print $NF }')") && pwd)
source $SCRIPT_HOME/common

[[ ! -e /root/.ipsecvpn_installed ]] || exit 0

if [[ "$config_vpn_type" != "ipsec" ]]; then
  echo "Skipping VPN setup as no VPN configuration found."
  exit 0
fi

IPSECVPN_DATA_HOME=/data/ipsecvpn
IPSECVPN_CONFIG=$IPSECVPN_DATA_HOME/etc

function apply_config() {

  if [[ ! -e $IPSECVPN_CONFIG/ipsec.d ]]; then
    echo "ERROR! It appears that IPSec configuration has not be run."
    exit 1
  fi

  if [[ ! -e /etc/ssl/certs/bastion_ca.pem ]]; then
    echo "ERROR! Unable to find the server certificates."
    exit 1
  fi

  rm -fr /etc/ipsec.d
  cp -r $IPSECVPN_CONFIG/ipsec.d /etc

  # Setup IPSec Keys
  cp /etc/ssl/certs/bastion_ca.pem /etc/ipsec.d/cacerts/
  cp /etc/ssl/certs/bastion_cert.pem /etc/ipsec.d/certs/
  cp /etc/ssl/private/bastion_key.pem /etc/ipsec.d/private/

  rm /etc/ipsec.conf /etc/ipsec.secrets
  cp $IPSECVPN_CONFIG/ipsec.conf /etc/ipsec.conf
  cp $IPSECVPN_CONFIG/ipsec.secrets /etc/ipsec.secrets

  mv $SCRIPT_HOME/create_ipsecvpn_user /usr/local/bin/create_vpn_user
  chmod +x /usr/local/bin/create_vpn_user
  mv $SCRIPT_HOME/delete_ipsecvpn_user /usr/local/bin/delete_vpn_user
  chmod +x /usr/local/bin/delete_vpn_user
}

function configure_ipsecvpn() {

  mkdir -p $IPSECVPN_CONFIG
  mv /etc/ipsec.d $IPSECVPN_CONFIG/ipsec.d

  # Use the fully qualified name
  # of the host instead of host ip.
  [[ $config_server_use_fqdn == "true" ]] && \
    config_server_host=$config_server_fqdn

  echo "export vpn_server=\"$config_server_host\"" > $IPSECVPN_CONFIG/serverinfo
  echo "export vpn_server_description=\"$config_vpn_server_description\"" >> $IPSECVPN_CONFIG/serverinfo
  echo "export vpn_server_domain=\"$config_vpn_server_domain\"" >> $IPSECVPN_CONFIG/serverinfo
  echo "export vpn_server_cert_country=\"$config_vpn_vpn_cert_country\"" >> $IPSECVPN_CONFIG/serverinfo
  echo "export vpn_server_cert_org=\"$config_vpn_vpn_cert_org\"" >> $IPSECVPN_CONFIG/serverinfo

  if [[ -e /root/.powerdns_installed ]]; then
    dns_servers=$config_powerdns_ns_ip
  else
    dns_servers=${config_vpn_dns_servers:-$config_server_dns_resolvers}
  fi

  cat << ---EOF >> $IPSECVPN_CONFIG/ipsec.conf
config setup
  uniqueids=never
  strictcrlpolicy=yes
  charondebug="cfg 2, dmn 2, ike 2, net 2"

conn %default
  auto=add
  compress=no
  type=tunnel
  keyexchange=ikev2
  fragmentation=yes
  forceencaps=yes

  # Ciphers
  ike=aes256gcm16-prfsha384-ecp521,aes256gcm16-prfsha384-ecp384,aes128gcm16-prfsha256-ecp256!
  esp=aes256gcm16-ecp521,aes256gcm16-ecp384,aes128gcm16-ecp256!

  # Dead peer detection will ping clients 
  # and terminate sessions after timeout
  dpdaction=clear
  dpddelay=300s
  rekey=no

  # Server side
  left=%any
  leftid=@${config_server_host}
  leftcert=bastion_cert.pem
  leftsendcert=always

  # Routes pushed to clients. This route 
  # sends all traffic via the VPN
  leftsubnet=0.0.0.0/0

  # Client side
  right=%any
  rightid=%any
  rightsourceip=${config_vpn_subnet}
  rightdns=${dns_servers}
  rightauth=eap-tls
  rightsendcert=always

  # Ask the client for user identity
  eap_identity=%identity

# MacOS clients
conn ikev2-mschapv2-apple
  rightauth=eap-tls

# Windows clients
conn ikev2-mschapv2
  rightauth=eap-tls
---EOF

  cat << ---EOF >> $IPSECVPN_CONFIG/ipsec.secrets
${config_server_host} : RSA "bastion_key.pem"
---EOF

  # Create rules to route VPN traffic to correct destinations
  public_itf=$(ip a \
    | grep -B 5 "$config_server_dmz_itf_ip" \
    | awk '/^[0-9]+: (eth|ens?)[0-9]+:/{ print substr($2,1,length($2)-1) }')
  
  # accept IPSec/NAT-T for VPN (ESP not needed with forceencaps, as ESP goes inside UDP)
  iptables -A INPUT -p udp --dport  500 -j ACCEPT
  iptables -A INPUT -p udp --dport 4500 -j ACCEPT

  # forward VPN traffic anywhere
  iptables -A FORWARD --match policy --pol ipsec --dir in  --proto esp -s $config_vpn_subnet -j ACCEPT
  iptables -A FORWARD --match policy --pol ipsec --dir out --proto esp -d $config_vpn_subnet -j ACCEPT

  # reduce MTU/MSS values for dumb VPN clients
  iptables -t mangle -A FORWARD --match policy --pol ipsec --dir in -s $config_vpn_subnet -o $public_itf \
    -p tcp -m tcp --tcp-flags SYN,RST SYN -m tcpmss --mss 1361:1536 -j TCPMSS --set-mss 1360

  # Exempt IPsec traffic from masquerading
  iptables -t nat -A POSTROUTING -o $public_itf -s $config_vpn_subnet -m policy --pol ipsec --dir out -j ACCEPT  
  # Masquerade traffic from VPN to "the world" -- done in the nat table
  iptables -t nat -A POSTROUTING -o $public_itf -s $config_vpn_subnet -j MASQUERADE
  
  # Create rules to route VPN traffic to the correct LAN destinations
  itfs=( $(ip a | awk '/^[0-9]+: (eth|ens?)[0-9]+:/{ print substr($2,1,length($2)-1) }') )
  i=0

  for n in $(echo $config_server_lan_interfaces | sed "s/,/ /g"); do

    itf=${itfs[$i]}
    i=$(($i+1))

    if [[ $itf != $public_itf ]]; then
      lan_subnet=$(echo $n | awk -F'|' '{print $3}')
      if [[ -z $lan_subnet ]]; then
        # If an explicit static route has not been provided 
        # default to the subnet the interface is attached to
        lan_subnet=$(echo $n | awk -F'|' '{print $2}')
      fi

      # Masquerade traffic from VPN to "LAN"
      iptables -t nat -I POSTROUTING -o $itf -s $config_vpn_subnet -j MASQUERADE

      # Allow traffic initiated from VPN to access LAN
      iptables -I FORWARD -i $public_itf -o $itf -s $config_vpn_subnet -d $lan_subnet -m conntrack --ctstate NEW -j ACCEPT      
    fi
  done
}

[[ -e $IPSECVPN_CONFIG/ipsec.conf ]] \
  || configure_ipsecvpn

apply_config
cat /dev/null > /var/log/syslog
ipsec restart

#
# Create VPN users
#

create_vpn_user \
  "$config_server_admin_user" \
  "$config_server_admin_passwd"

for u in $(echo $config_vpn_users | sed "s/,/ /g"); do
  user=$(echo $u | awk -F'|' '{print $1}')
  passwd=$(echo $u | awk -F'|' '{print $2}')

  create_vpn_user "$user" "$passwd"
done

set +ex
touch /root/.ipsecvpn_installed
